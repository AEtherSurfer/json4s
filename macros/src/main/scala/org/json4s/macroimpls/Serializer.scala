package org.json4s.macroimpls

import language.experimental.macros
import scala.reflect.macros.Context

import org.json4s.{Formats, JsonWriter, JValue, JObject}
import macrohelpers._


// Intended to be the serialization side of the class builder
object Serializer {
  
  type Writer = JsonWriter[_]

  // Makes the code generated by the macros significantly less cumbersome
  private[this] class WriterStack(var current:Writer) {
    def startArray() = {
      current = current.startArray()
      current
    }
    def endArray() = {
      current = current.endArray()
      current
    }
    def startObject() = {
      current = current.startObject()
      current
    }
    def endObject() = {
      current = current.endObject()
      current
    }
    def primative(value:Any) = { 
      current = value match {
        case a:Int        => current.int(a)
        case a:String     => current.string(a)
        case a:Float      => current.float(a)
        case a:Double     => current.double(a)
        case a:Boolean    => current.boolean(a)
        case a:Long       => current.long(a)
        case a:Byte       => current.byte(a)
        case a:BigInt     => current.bigInt(a)
        case a:Short      => current.short(a)
        case a:BigDecimal => current.bigDecimal(a)
      }
      current
    }
    def startField(name: String) = {
      current = current.startField(name)
      current
    }
    def addJValue(jv: JValue) = {
      current = current.addJValue(jv)
      current
    }
    def result = current.result
  }

  /* ----------------- Offers directly to object serialization -------------------------- */
  def serializeToObject[U](obj: U)(implicit defaultFormats: Formats) = macro implSerToObj[U]
  def implSerToObj[U: c.WeakTypeTag](c: Context)(obj: c.Expr[U])(defaultFormats: c.Expr[Formats]): c.Expr[JObject] = {
    import c.universe._

    reify {
      val writer = JsonWriter.ast

      {impl(c)(obj, c.Expr[String]{Literal(Constant("tmpname"))}, c.Expr[Writer](Ident("writer")))(defaultFormats)}.splice
      val jobj: JObject = writer.result.asInstanceOf[JObject]
      val JObject(("tmpname", result)::Nil) = jobj // Now just extract the object from the wrapper
      result.asInstanceOf[JObject]
    }
  }

  /* ----------------- Macro Serializer ----------------- */
  def serialize[U](obj: U, name: String, writer: Writer)(implicit defaultFormats: Formats) = macro impl[U]
  def impl[U: c.WeakTypeTag](c: Context)(obj: c.Expr[U], name: c.Expr[String], writer: c.Expr[Writer])
                           (defaultFormats: c.Expr[Formats]): c.Expr[Unit] = {
                      
    import c.universe._
    val helpers = new macrohelpers.MacroHelpers[c.type](c)
    import helpers._
    
    // Will help manage the JsonWriters for us instead of having to
    // keep track as we go down the tree
    val Block(writerStackDef::Nil, _) = reify{
      val writerStack = new WriterStack(writer.splice)
    }.tree
    val writerStack = c.Expr[WriterStack](Ident("writerStack"))

    // TODO: Add Date and Symbol abilities
    val primitiveTypes = typeOf[Int]::typeOf[String]::
                          typeOf[Float]::typeOf[Double]::
                          typeOf[Boolean]::typeOf[Long]::
                          typeOf[Byte]::typeOf[BigInt]::
                          typeOf[Short]::typeOf[BigDecimal]::Nil
    
    
    // Assumes that you are already in an object or list
    def dumpObject(tpe: Type, path: Tree, name: c.Expr[String], isList: Boolean=false): c.Tree = {
      
      val startFieldExpr = if(isList) {
        reify{}
      } else reify{writerStack.splice.startField(name.splice)}
      
      if(primitiveTypes.exists(_ =:= tpe)) { // Must be primative
        reify{
          startFieldExpr.splice
          writerStack.splice.primative(c.Expr(path).splice)
        }.tree
      } 
      // Handle the lists
      else if(tpe <:< typeOf[scala.collection.Seq[Any]]) {
        val TypeRef(_, sym:Symbol, pTpe::Nil) = tpe
        reify{
          startFieldExpr.splice
          writerStack.splice.startArray()
          c.Expr[scala.collection.Seq[Any]](path).splice.foreach { i =>
            c.Expr(dumpObject(pTpe, Ident("i"), LIT(""), isList=true)).splice
          }
          writerStack.splice.endArray()
        }.tree
      } 
      
      else if(tpe <:< typeOf[scala.collection.GenMap[Any, Any]].erasure) {
        val TypeRef(_, _, keyTpe::valTpe::Nil) = tpe
        
        if(!primitiveTypes.exists(_ =:= keyTpe)) {
          c.abort(c.enclosingPosition,
            s"Maps nees to have keys of primative type! Type: $keyTpe")
        }
        val kExpr = c.Expr[String](Ident("kstr"))
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
          c.Expr[scala.collection.GenMap[Any, Any]](path).splice.foreach { case (k, v) =>
            val kstr = k.toString
            c.Expr(dumpObject(valTpe, Ident("v"), kExpr)).splice
          }
          writerStack.splice.endObject()
          
        }.tree
        
      // Handle Options
      } else if(tpe <:< typeOf[Option[Any]]) {
        val TypeRef(_, sym:Symbol, pTpe::Nil) = tpe
        reify{
        // I would be happier if I could to c.Expr[Option["real type"]]
        // but this seems to work. I'm not sure if its just for type
        // checking in reify or what...
          PrimativeHelpers.optIdent(c.Expr[Option[Any]](path).splice) match {
            case Some(x) => c.Expr[Unit](dumpObject(pTpe, Ident("x"), name)).splice
            case None    => {
              startFieldExpr.splice
              writerStack.splice.addJValue(org.json4s.JNothing)
            }
          }
        }.tree
      } 
      
      else {  // Complex object
        val TypeRef(_, sym:Symbol, tpeArgs:List[Type]) = tpe
        // get fields
        val fields = getVars(tpe):::getVals(tpe)
        val fieldTrees = fields map { pSym => 
          val pTpe = pSym.typeSignature.substituteTypes(sym.asClass.typeParams, tpeArgs)
          val fieldName = pSym.name.decoded.trim    // Do I need to trim here?
          val fieldPath = Select(path, newTermName(fieldName))
          dumpObject(pTpe, fieldPath, LIT(fieldName))
        }
        
        // Return add all the blocks for each field and pop this obj off the stack
        Block(
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
        }.tree::fieldTrees,
        reify{writerStack.splice.endObject()}.tree)
      }
    } // dumpObject
    
    val code = Block(
      writerStackDef::
      reify(
        writerStack.splice.startObject()
      ).tree::
      dumpObject(weakTypeOf[U], obj.tree, name)::
      reify(
        writerStack.splice.endObject()
      ).tree::Nil,
      c.literalUnit.tree
    )
    // println(s"------------------ Debug: Generated Code ------------------\n $code")
    c.Expr[Unit](code)
  }
  
}
